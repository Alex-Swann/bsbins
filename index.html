<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Stortford Bin Collection</title>
<style>
  body { font-family: Arial, sans-serif; max-width: 600px; margin: 1rem auto; padding: 0 1rem; }
  label, input, button { display: block; margin: 0.5rem 0; font-size: 1rem; }
  button { padding: 0.5rem; }
  #results p, #results ul { margin-top: 1rem; }
</style>
</head>
<body>
  <h1>Stortford Bin Collection Lookup</h1>

  <label for="postcode">Postcode:</label>
  <input type="text" id="postcode" placeholder="e.g. CM23 5HE or CM235HE" autocomplete="postal-code" />

  <label for="housenumber">House Number:</label>
  <input type="text" id="housenumber" placeholder="e.g. 41" />

  <button id="getCollections">Get Bin Collections</button>

  <div id="results" aria-live="polite"></div>

<script>
  const getCollectionsBtn = document.getElementById('getCollections');
  const postcodeInput = document.getElementById('postcode');
  const houseNumberInput = document.getElementById('housenumber');
  const resultsDiv = document.getElementById('results');

  function normalizePostcode(pc) {
    return pc.toUpperCase().replace(/\s/g, '');
  }

  async function searchAddresses(postcode) {
    const resp = await fetch('/api/search-addresses', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ postcode }),
    });
    if (!resp.ok) throw new Error('Failed to search addresses');
    return await resp.json();
  }

  async function getPropertyDetails(uprn, address, propertyType) {
    const resp = await fetch('/api/property-details', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ uprn, address, propertyType }),
    });
    if (!resp.ok) throw new Error('Failed to get property details');
    return await resp.json();
  }

  const binCycle = [
    ['black', 'brown', 'food'],    // Week 1 (week commencing 4 Aug 2025)
    ['blue', 'food'],              // Week 2
    ['purple', 'brown', 'food'],   // Week 3
    ['black', 'food'],             // Week 4
    ['blue', 'brown', 'food'],     // Week 5
    ['purple', 'food']             // Week 6
  ];

  const anchorDate = new Date('2025-08-04T00:00:00Z');

  function getCycleWeek(today, anchor) {
    const msInWeek = 1000 * 60 * 60 * 24 * 7;
    const diffWeeks = Math.floor((today - anchor) / msInWeek);
    return ((diffWeeks % 6) + 6) % 6; // positive modulo
  }

  function getCorrectedBinSchedule(startDate) {
    const today = new Date();
    // Use anchorDate if today is before it, else use today
    const baseDate = today < anchorDate ? anchorDate : today;

    // Round baseDate to Monday (week start) to align with cycles
    const day = baseDate.getDay(); // Sunday=0, Monday=1, ...
    const diffToMonday = (day === 0 ? -6 : 1 - day); // how many days to Monday
    const monday = new Date(baseDate);
    monday.setDate(baseDate.getDate() + diffToMonday);

    const weekIndex = getCycleWeek(monday, anchorDate);

    const schedule = [];
    for (let i = 0; i < 6; i++) {
      const date = new Date(monday);
      date.setDate(monday.getDate() + i * 7);
      const bins = binCycle[(weekIndex + i) % 6];
      schedule.push({ week: i + 1, date, bins });
    }
    return schedule;
  }

  function ordinal(n) {
    if (n > 3 && n < 21) return n + 'th';
    switch (n % 10) {
      case 1: return n + 'st';
      case 2: return n + 'nd';
      case 3: return n + 'rd';
      default: return n + 'th';
    }
  }

  function formatDate(d) {
    const weekday = d.toLocaleDateString('en-GB', { weekday: 'long' });
    const day = ordinal(d.getDate());
    const month = d.toLocaleDateString('en-GB', { month: 'long' });
    return `${weekday} ${day} ${month}`;
  }

  function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  function formatBinWeekOutput(schedule) {
    const first = schedule[0];
    let result = `<p><strong>Your next collection is on ${formatDate(first.date)}: ${first.bins.map(capitalize).join(', ')}</strong></p>`;
    result += `<p><strong>Following weeks:</strong></p><ul>`;
    for (let i = 1; i < schedule.length; i++) {
      const week = schedule[i];
      result += `<li><strong>Week ${week.week}</strong> â€“ ${formatDate(week.date)}: ${week.bins.map(capitalize).join(', ')}</li>`;
    }
    result += '</ul>';
    return result;
  }

  getCollectionsBtn.addEventListener('click', async () => {
    resultsDiv.textContent = '';
    let pc = normalizePostcode(postcodeInput.value);
    let hn = houseNumberInput.value.trim();

    if (!pc) {
      alert('Please enter a postcode.');
      return;
    }
    if (!hn) {
      alert('Please enter a house number.');
      return;
    }

    resultsDiv.textContent = 'Looking up addresses...';

    try {
      const data = await searchAddresses(pc);
      if (!data.addresses || data.addresses.length === 0) {
        resultsDiv.textContent = 'No addresses found for that postcode.';
        return;
      }

      // Find address matching house number (simple case-insensitive substring)
      const matched = data.addresses.find(a =>
        a.address.toLowerCase().includes(hn.toLowerCase())
      );

      if (!matched) {
        resultsDiv.textContent = 'No address found matching that house number.';
        return;
      }

      resultsDiv.textContent = 'Fetching collection details...';

      const propDetails = await getPropertyDetails(matched.uprn, matched.address, matched.propertyType);

      // Ignore API returned collection dates and use our cycle instead
      const schedule = getCorrectedBinSchedule();

      resultsDiv.innerHTML = formatBinWeekOutput(schedule);

    } catch (e) {
      resultsDiv.textContent = 'Error: ' + e.message;
    }
  });
</script>
</body>
</html>
